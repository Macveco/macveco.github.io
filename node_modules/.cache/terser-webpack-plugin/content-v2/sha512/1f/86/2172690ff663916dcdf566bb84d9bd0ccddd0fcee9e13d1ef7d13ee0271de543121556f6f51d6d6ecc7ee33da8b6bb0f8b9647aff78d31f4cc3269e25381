{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{488:function(e,s,t){\"use strict\";t.r(s);var n=t(42),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"编写-猜猜看-游戏\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#编写-猜猜看-游戏\"}},[e._v(\"#\")]),e._v(\" 编写 猜猜看 游戏\")]),e._v(\" \"),t(\"blockquote\",[t(\"p\",[t(\"a\",{attrs:{href:\"https://github.com/rust-lang/book/blob/master/src/ch02-00-guessing-game-tutorial.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"ch02-00-guessing-game-tutorial.md\"),t(\"OutboundLink\")],1),e._v(\" \"),t(\"br\"),e._v(\"\\ncommit c427a676393d001edc82f1a54a3b8026abcf9690\")])]),e._v(\" \"),t(\"p\",[e._v(\"让我们一起动手完成一个项目，来快速上手 Rust！本章将介绍 Rust 中一些常用概念，并通过真实的程序来展示如何运用它们。你将会学到 \"),t(\"code\",[e._v(\"let\")]),e._v(\"、\"),t(\"code\",[e._v(\"match\")]),e._v(\"、方法、关联函数、外部 crate 等知识！后续章节会深入探讨这些概念的细节。在这一章，我们将做基础练习。\")]),e._v(\" \"),t(\"p\",[e._v(\"我们会实现一个经典的新手编程问题：猜猜看游戏。它是这么工作的：程序将会随机生成一个 1 到 100 之间的随机整数。接着它会请玩家猜一个数并输入，然后提示猜测是大了还是小了。如果猜对了，它会打印祝贺信息并退出。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"准备一个新项目\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#准备一个新项目\"}},[e._v(\"#\")]),e._v(\" 准备一个新项目\")]),e._v(\" \"),t(\"p\",[e._v(\"要创建一个新项目，进入第一章中创建的 \"),t(\"em\",[e._v(\"projects\")]),e._v(\" 目录，使用 Cargo 新建一个项目，如下：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo new guessing_game\\n$ cd guessing_game\\n\")])])]),t(\"p\",[e._v(\"第一个命令，\"),t(\"code\",[e._v(\"cargo new\")]),e._v(\"，它获取项目的名称（\"),t(\"code\",[e._v(\"guessing_game\")]),e._v(\"）作为第一个参数。第二个命令进入到新创建的项目目录。\")]),e._v(\" \"),t(\"p\",[e._v(\"看看生成的 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 文件：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: Cargo.toml\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-toml extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-toml\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),t(\"span\",{pre:!0,attrs:{class:\"token table class-name\"}},[e._v(\"package\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"name\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"guessing_game\"')]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"version\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"0.1.0\"')]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"authors\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"Your Name <you@example.com>\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"edition\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"2018\"')]),e._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),t(\"span\",{pre:!0,attrs:{class:\"token table class-name\"}},[e._v(\"dependencies\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"如果 Cargo 从环境中获取的开发者信息不正确，修改这个文件并再次保存。\")]),e._v(\" \"),t(\"p\",[e._v(\"正如第一章那样，\"),t(\"code\",[e._v(\"cargo new\")]),e._v(\" 生成了一个 “Hello, world!” 程序。查看 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\" 文件：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-rust\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"fn\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function-definition function\"}},[e._v(\"main\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),e._v(\"\\n    \"),t(\"span\",{pre:!0,attrs:{class:\"token macro property\"}},[e._v(\"println!\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"Hello, world!\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"现在使用 \"),t(\"code\",[e._v(\"cargo run\")]),e._v(\" 命令，一步完成 “Hello, world!” 程序的编译和运行：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs\\n     Running `target/debug/guessing_game`\\nHello, world!\\n\")])])]),t(\"p\",[e._v(\"当你需要在项目中快速迭代时，\"),t(\"code\",[e._v(\"run\")]),e._v(\" 命令就能派上用场，正如我们在这个游戏项目中做的，在下一次迭代之前快速测试每一次迭代。\")]),e._v(\" \"),t(\"p\",[e._v(\"重新打开 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\" 文件。我们将会在这个文件中编写全部的代码。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"处理一次猜测\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#处理一次猜测\"}},[e._v(\"#\")]),e._v(\" 处理一次猜测\")]),e._v(\" \"),t(\"p\",[e._v(\"猜猜看程序的第一部分请求和处理用户输入，并检查输入是否符合预期的格式。首先，允许玩家输入猜测。在 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\" 中输入示例 2-1 中的代码。\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('use std::io;\\n\\nfn main() {\\n    println!(\"Guess the number!\");\\n\\n    println!(\"Please input your guess.\");\\n\\n    let mut guess = String::new();\\n\\n    io::stdin().read_line(&mut guess)\\n        .expect(\"Failed to read line\");\\n\\n    println!(\"You guessed: {}\", guess);\\n}\\n')])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-1：获取用户猜测并打印的代码\")])]),e._v(\" \"),t(\"p\",[e._v(\"这些代码包含很多信息，我们一行一行地过一遍。为了获取用户输入并打印结果作为输出，我们需要将 \"),t(\"code\",[e._v(\"io\")]),e._v(\"（输入/输出）库引入当前作用域。\"),t(\"code\",[e._v(\"io\")]),e._v(\" 库来自于标准库（也被称为 \"),t(\"code\",[e._v(\"std\")]),e._v(\"）：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"use std::io;\\n\")])])]),t(\"p\",[e._v(\"默认情况下，Rust 将 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/prelude/index.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"em\",[e._v(\"prelude\")]),t(\"OutboundLink\")],1),e._v(\" 模块中少量的类型引入到每个程序的作用域中。如果需要的类型不在 prelude 中，你必须使用 \"),t(\"code\",[e._v(\"use\")]),e._v(\" 语句显式地将其引入作用域。\"),t(\"code\",[e._v(\"std::io\")]),e._v(\" 库提供很多有用的功能，包括接收用户输入的功能。\")]),e._v(\" \"),t(\"p\",[e._v(\"如第一章所提及，\"),t(\"code\",[e._v(\"main\")]),e._v(\" 函数是程序的入口点：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"fn main() {\\n\")])])]),t(\"p\",[t(\"code\",[e._v(\"fn\")]),e._v(\" 语法声明了一个新函数，\"),t(\"code\",[e._v(\"()\")]),e._v(\" 表明没有参数，\"),t(\"code\",[e._v(\"{\")]),e._v(\" 作为函数体的开始。\")]),e._v(\" \"),t(\"p\",[e._v(\"第一章也提及了 \"),t(\"code\",[e._v(\"println!\")]),e._v(\" 是一个在屏幕上打印字符串的宏：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('println!(\"Guess the number!\");\\n\\nprintln!(\"Please input your guess.\");\\n')])])]),t(\"p\",[e._v(\"这些代码仅仅打印提示，介绍游戏的内容然后请求用户输入。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"使用变量储存值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用变量储存值\"}},[e._v(\"#\")]),e._v(\" 使用变量储存值\")]),e._v(\" \"),t(\"p\",[e._v(\"接下来，创建一个储存用户输入的地方，像这样：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"let mut guess = String::new();\\n\")])])]),t(\"p\",[e._v(\"现在程序开始变得有意思了！这一小行代码发生了很多事。注意这是一个 \"),t(\"code\",[e._v(\"let\")]),e._v(\" 语句，用来创建 \"),t(\"strong\",[e._v(\"变量\")]),e._v(\"（\"),t(\"em\",[e._v(\"variable\")]),e._v(\"）。这里是另外一个例子：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"let foo = bar;\\n\")])])]),t(\"p\",[e._v(\"这行代码新建了一个叫做 \"),t(\"code\",[e._v(\"foo\")]),e._v(\" 的变量并把它绑定到值 \"),t(\"code\",[e._v(\"bar\")]),e._v(\" 上。在 Rust 中，变量默认是不可变的。我们将会在第三章的 \"),t(\"RouterLink\",{attrs:{to:\"/ch03-01-variables-and-mutability.html#variables-and-mutability\"}},[e._v(\"“变量与可变性”\")]),e._v(\" 部分详细讨论这个概念。下面的例子展示了如何在变量名前使用 \"),t(\"code\",[e._v(\"mut\")]),e._v(\" 来使一个变量可变：\")],1),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"let foo = 5; // 不可变\\nlet mut bar = 5; // 可变\\n\")])])]),t(\"blockquote\",[t(\"p\",[e._v(\"注意：\"),t(\"code\",[e._v(\"//\")]),e._v(\" 语法开始一个注释，持续到行尾。Rust 忽略注释中的所有内容，第三章将会详细介绍注释。\")])]),e._v(\" \"),t(\"p\",[e._v(\"让我们回到猜猜看程序中。现在我们知道了 \"),t(\"code\",[e._v(\"let mut guess\")]),e._v(\" 会引入一个叫做 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 的可变变量。等号（\"),t(\"code\",[e._v(\"=\")]),e._v(\"）的右边是 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 所绑定的值，它是 \"),t(\"code\",[e._v(\"String::new\")]),e._v(\" 的结果，这个函数会返回一个 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 的新实例。\"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/string/struct.String.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"String\")]),t(\"OutboundLink\")],1),e._v(\" 是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"::new\")]),e._v(\" 那一行的 \"),t(\"code\",[e._v(\"::\")]),e._v(\" 语法表明 \"),t(\"code\",[e._v(\"new\")]),e._v(\" 是 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 类型的一个 \"),t(\"strong\",[e._v(\"关联函数\")]),e._v(\"（\"),t(\"em\",[e._v(\"associated function\")]),e._v(\"）。关联函数是针对类型实现的，在这个例子中是 \"),t(\"code\",[e._v(\"String\")]),e._v(\"，而不是 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 的某个特定实例。一些语言中把它称为 \"),t(\"strong\",[e._v(\"静态方法\")]),e._v(\"（\"),t(\"em\",[e._v(\"static method\")]),e._v(\"）。\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"new\")]),e._v(\" 函数创建了一个新的空字符串，你会发现很多类型上有 \"),t(\"code\",[e._v(\"new\")]),e._v(\" 函数，因为它是创建类型实例的惯用函数名。\")]),e._v(\" \"),t(\"p\",[e._v(\"总结一下，\"),t(\"code\",[e._v(\"let mut guess = String::new();\")]),e._v(\" 这一行创建了一个可变变量，当前它绑定到一个新的 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 空实例上。\")]),e._v(\" \"),t(\"p\",[e._v(\"回忆一下，我们在程序的第一行使用 \"),t(\"code\",[e._v(\"use std::io;\")]),e._v(\" 从标准库中引入了输入/输出功能。现在调用 \"),t(\"code\",[e._v(\"io\")]),e._v(\" 库中的函数 \"),t(\"code\",[e._v(\"stdin\")]),e._v(\"：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('io::stdin().read_line(&mut guess)\\n    .expect(\"Failed to read line\");\\n')])])]),t(\"p\",[e._v(\"如果程序的开头没有 \"),t(\"code\",[e._v(\"use std::io\")]),e._v(\" 这一行，可以把函数调用写成 \"),t(\"code\",[e._v(\"std::io::stdin\")]),e._v(\"。\"),t(\"code\",[e._v(\"stdin\")]),e._v(\" 函数返回一个 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/io/struct.Stdin.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"std::io::Stdin\")]),t(\"OutboundLink\")],1),e._v(\" 的实例，这代表终端标准输入句柄的类型。\")]),e._v(\" \"),t(\"p\",[e._v(\"代码的下一部分，\"),t(\"code\",[e._v(\".read_line(&mut guess)\")]),e._v(\"，调用 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"read_line\")]),t(\"OutboundLink\")],1),e._v(\" 方法从标准输入句柄获取用户输入。我们还向 \"),t(\"code\",[e._v(\"read_line()\")]),e._v(\" 传递了一个参数：\"),t(\"code\",[e._v(\"&mut guess\")]),e._v(\"。\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"read_line\")]),e._v(\" 的工作是，无论用户在标准输入中键入什么内容，都将其存入一个字符串中，因此它需要字符串作为参数。这个字符串参数应该是可变的，以便 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 将用户输入附加上去。\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"&\")]),e._v(\" 表示这个参数是一个 \"),t(\"strong\",[e._v(\"引用\")]),e._v(\"（\"),t(\"em\",[e._v(\"reference\")]),e._v(\"），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。引用是一个复杂的特性，Rust 的一个主要优势就是安全而简单的操纵引用。完成当前程序并不需要了解如此多细节。现在，我们只需知道它像变量一样，默认是不可变的。因此，需要写成 \"),t(\"code\",[e._v(\"&mut guess\")]),e._v(\" 来使其可变，而不是 \"),t(\"code\",[e._v(\"&guess\")]),e._v(\"。（第四章会更全面的解释引用。）\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"使用-result-类型来处理潜在的错误\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-result-类型来处理潜在的错误\"}},[e._v(\"#\")]),e._v(\" 使用 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型来处理潜在的错误\")]),e._v(\" \"),t(\"p\",[e._v(\"我们还没有完全分析完这行代码。虽然这是单独一行代码，但它是逻辑行（虽然换行了但仍是语句）的一部分。后一部分是这个方法：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('.expect(\"Failed to read line\");\\n')])])]),t(\"p\",[e._v(\"当使用 \"),t(\"code\",[e._v(\".foo()\")]),e._v(\" 语法调用方法时，通过换行加缩进来把长行拆开是明智的。我们完全可以这样写：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('io::stdin().read_line(&mut guess).expect(\"Failed to read line\");\\n')])])]),t(\"p\",[e._v(\"不过，过长的行难以阅读，所以最好拆开来写，两个方法调用占两行。现在来看看这行代码干了什么。\")]),e._v(\" \"),t(\"p\",[e._v(\"之前提到了 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 将用户输入附加到传递给它的字符串中，不过它也返回一个值——在这个例子中是 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/io/type.Result.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"io::Result\")]),t(\"OutboundLink\")],1),e._v(\"。Rust 标准库中有很多叫做 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 的类型：一个通用的 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/result/enum.Result.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"Result\")]),t(\"OutboundLink\")],1),e._v(\" 以及在子模块中的特化版本，比如 \"),t(\"code\",[e._v(\"io::Result\")]),e._v(\"。\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"Result\")]),e._v(\" 类型是 \"),t(\"RouterLink\",{attrs:{to:\"/ch06-00-enums.html\"}},[t(\"em\",[e._v(\"枚举\")]),e._v(\"（\"),t(\"em\",[e._v(\"enumerations\")]),e._v(\"）\")]),e._v(\"，通常也写作 \"),t(\"em\",[e._v(\"enums\")]),e._v(\"。枚举类型持有固定集合的值，这些值被称为枚举的 \"),t(\"strong\",[e._v(\"成员\")]),e._v(\"（\"),t(\"em\",[e._v(\"variants\")]),e._v(\"）。第六章将介绍枚举的更多细节。\")],1),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"Result\")]),e._v(\" 的成员是 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"Err\")]),e._v(\"，\"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 成员表示操作成功，内部包含成功时产生的值。\"),t(\"code\",[e._v(\"Err\")]),e._v(\" 成员则意味着操作失败，并且包含失败的前因后果。\")]),e._v(\" \"),t(\"p\",[e._v(\"这些 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型的作用是编码错误处理信息。\"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型的值，像其他类型一样，拥有定义于其上的方法。\"),t(\"code\",[e._v(\"io::Result\")]),e._v(\" 的实例拥有 \"),t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/result/enum.Result.html#method.expect\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"expect\")]),e._v(\" 方法\"),t(\"OutboundLink\")],1),e._v(\"。如果 \"),t(\"code\",[e._v(\"io::Result\")]),e._v(\" 实例的值是 \"),t(\"code\",[e._v(\"Err\")]),e._v(\"，\"),t(\"code\",[e._v(\"expect\")]),e._v(\" 会导致程序崩溃，并显示当做参数传递给 \"),t(\"code\",[e._v(\"expect\")]),e._v(\" 的信息。如果 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 方法返回 \"),t(\"code\",[e._v(\"Err\")]),e._v(\"，则可能是来源于底层操作系统错误的结果。如果 \"),t(\"code\",[e._v(\"io::Result\")]),e._v(\" 实例的值是 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\"，\"),t(\"code\",[e._v(\"expect\")]),e._v(\" 会获取 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。\")]),e._v(\" \"),t(\"p\",[e._v(\"如果不调用 \"),t(\"code\",[e._v(\"expect\")]),e._v(\"，程序也能编译，不过会出现一个警告：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo build\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\nwarning: unused `std::result::Result` which must be used\\n  --\\x3e src/main.rs:10:5\\n   |\\n10 |     io::stdin().read_line(&mut guess);\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n   |\\n   = note: #[warn(unused_must_use)] on by default\\n\")])])]),t(\"p\",[e._v(\"Rust 警告我们没有使用 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 的返回值 \"),t(\"code\",[e._v(\"Result\")]),e._v(\"，说明有一个可能的错误没有处理。\")]),e._v(\" \"),t(\"p\",[e._v(\"消除警告的正确做法是实际编写错误处理代码，不过由于我们就是希望程序在出现问题时立即崩溃，所以直接使用 \"),t(\"code\",[e._v(\"expect\")]),e._v(\"。第九章会学习如何从错误中恢复。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"使用-println-占位符打印值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-println-占位符打印值\"}},[e._v(\"#\")]),e._v(\" 使用 \"),t(\"code\",[e._v(\"println!\")]),e._v(\" 占位符打印值\")]),e._v(\" \"),t(\"p\",[e._v(\"除了位于结尾的大括号，目前为止就只有这一行代码值得讨论一下了，就是这一行：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('println!(\"You guessed: {}\", guess);\\n')])])]),t(\"p\",[e._v(\"这行代码打印存储用户输入的字符串。第一个参数是格式化字符串，里面的 \"),t(\"code\",[e._v(\"{}\")]),e._v(\" 是预留在特定位置的占位符。使用 \"),t(\"code\",[e._v(\"{}\")]),e._v(\" 也可以打印多个值：第一对 \"),t(\"code\",[e._v(\"{}\")]),e._v(\" 使用格式化字符串之后的第一个值，第二对则使用第二个值，依此类推。调用一次 \"),t(\"code\",[e._v(\"println!\")]),e._v(\" 打印多个值看起来像这样：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-rust\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"let\")]),e._v(\" x \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[e._v(\"5\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"let\")]),e._v(\" y \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[e._v(\"10\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token macro property\"}},[e._v(\"println!\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"x = {} and y = {}\"')]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" x\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" y\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"这行代码会打印出 \"),t(\"code\",[e._v(\"x = 5 and y = 10\")]),e._v(\"。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"测试第一部分代码\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#测试第一部分代码\"}},[e._v(\"#\")]),e._v(\" 测试第一部分代码\")]),e._v(\" \"),t(\"p\",[e._v(\"让我们来测试下猜猜看游戏的第一部分。使用 \"),t(\"code\",[e._v(\"cargo run\")]),e._v(\" 运行：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nPlease input your guess.\\n6\\nYou guessed: 6\\n\")])])]),t(\"p\",[e._v(\"至此为止，游戏的第一部分已经完成：我们从键盘获取输入并打印了出来。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"生成一个秘密数字\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#生成一个秘密数字\"}},[e._v(\"#\")]),e._v(\" 生成一个秘密数字\")]),e._v(\" \"),t(\"p\",[e._v(\"接下来，需要生成一个秘密数字，好让用户来猜。秘密数字应该每次都不同，这样重复玩才不会乏味；范围应该在 1 到 100 之间，这样才不会太困难。Rust 标准库中尚未包含随机数功能。然而，Rust 团队还是提供了一个 \"),t(\"a\",{attrs:{href:\"https://crates.io/crates/rand\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"rand\")]),e._v(\" crate\"),t(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"使用-crate-来增加更多功能\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-crate-来增加更多功能\"}},[e._v(\"#\")]),e._v(\" 使用 crate 来增加更多功能\")]),e._v(\" \"),t(\"p\",[e._v(\"记住，\"),t(\"em\",[e._v(\"crate\")]),e._v(\" 是一个 Rust 代码包。我们正在构建的项目是一个 \"),t(\"strong\",[e._v(\"二进制 crate\")]),e._v(\"，它生成一个可执行文件。 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 是一个 \"),t(\"strong\",[e._v(\"库 crate\")]),e._v(\"，库 crate 可以包含任意能被其他程序使用的代码。\")]),e._v(\" \"),t(\"p\",[e._v(\"Cargo 对外部 crate 的运用是其真正闪光的地方。在我们使用 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" 编写代码之前，需要修改 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 文件，引入一个 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" 依赖。现在打开这个文件并在底部的 \"),t(\"code\",[e._v(\"[dependencies]\")]),e._v(\" 片段标题之下添加：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: Cargo.toml\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-toml extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-toml\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),t(\"span\",{pre:!0,attrs:{class:\"token table class-name\"}},[e._v(\"dependencies\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"rand\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"0.5.5\"')]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"在 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 文件中，标题以及之后的内容属同一个片段，直到遇到下一个标题才开始新的片段。\"),t(\"code\",[e._v(\"[dependencies]\")]),e._v(\" 片段告诉 Cargo 本项目依赖了哪些外部 crate 及其版本。本例中，我们使用语义化版本 \"),t(\"code\",[e._v(\"0.5.5\")]),e._v(\" 来指定 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate。Cargo 理解\"),t(\"a\",{attrs:{href:\"http://semver.org\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"语义化版本（Semantic Versioning）\"),t(\"OutboundLink\")],1),e._v(\"（有时也称为 \"),t(\"em\",[e._v(\"SemVer\")]),e._v(\"），这是一种定义版本号的标准。\"),t(\"code\",[e._v(\"0.5.5\")]),e._v(\" 事实上是 \"),t(\"code\",[e._v(\"^0.5.5\")]),e._v(\" 的简写，它表示 “任何与 0.5.5 版本公有 API 相兼容的版本”。\")]),e._v(\" \"),t(\"p\",[e._v(\"现在，不修改任何代码，构建项目，如示例 2-2 所示：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo build\\n    Updating crates.io index\\n  Downloaded rand v0.5.5\\n  Downloaded libc v0.2.62\\n  Downloaded rand_core v0.2.2\\n  Downloaded rand_core v0.3.1\\n  Downloaded rand_core v0.4.2\\n   Compiling rand_core v0.4.2\\n   Compiling libc v0.2.62\\n   Compiling rand_core v0.3.1\\n   Compiling rand_core v0.2.2\\n   Compiling rand v0.5.5\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53 s\\n\")])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-2: 将 rand crate 添加为依赖之后运行 \"),t(\"code\",[e._v(\"cargo build\")]),e._v(\" 的输出\")])]),e._v(\" \"),t(\"p\",[e._v(\"可能会出现不同的版本号（多亏了语义化版本，它们与代码是兼容的！），同时显示顺序也可能会有所不同。\")]),e._v(\" \"),t(\"p\",[e._v(\"现在我们有了一个外部依赖，Cargo 从 \"),t(\"em\",[e._v(\"registry\")]),e._v(\" 上获取所有包的最新版本信息，这是一份来自 \"),t(\"a\",{attrs:{href:\"https://crates.io\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Crates.io\"),t(\"OutboundLink\")],1),e._v(\" 的数据拷贝。Crates.io 是 Rust 生态环境中的开发者们向他人贡献 Rust 开源项目的地方。\")]),e._v(\" \"),t(\"p\",[e._v(\"在更新完 registry 后，Cargo 检查 \"),t(\"code\",[e._v(\"[dependencies]\")]),e._v(\" 片段并下载缺失的 crate 。本例中，虽然只声明了 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" 一个依赖，然而 Cargo 还是额外获取了 \"),t(\"code\",[e._v(\"libc\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"rand_core\")]),e._v(\" 的拷贝，因为 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" 依赖 \"),t(\"code\",[e._v(\"libc\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"rand_core\")]),e._v(\" 来正常工作。下载完成后，Rust 编译依赖，然后使用这些依赖编译项目。\")]),e._v(\" \"),t(\"p\",[e._v(\"如果不做任何修改，立刻再次运行 \"),t(\"code\",[e._v(\"cargo build\")]),e._v(\"，则不会看到任何除了 \"),t(\"code\",[e._v(\"Finished\")]),e._v(\" 行之外的输出。Cargo 知道它已经下载并编译了依赖，同时 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 文件也没有变动。Cargo 还知道代码也没有任何修改，所以它不会重新编译代码。因为无事可做，它简单的退出了。\")]),e._v(\" \"),t(\"p\",[e._v(\"如果打开 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\" 文件，做一些无关紧要的修改，保存并再次构建，则会出现两行输出：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo build\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs\\n\")])])]),t(\"p\",[e._v(\"这一行表示 Cargo 只针对 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\" 文件的微小修改而更新构建。依赖没有变化，所以 Cargo 知道它可以复用已经为此下载并编译的代码。它只是重新构建了部分（项目）代码。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"cargo-lock-文件确保构建是可重现的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cargo-lock-文件确保构建是可重现的\"}},[e._v(\"#\")]),e._v(\" \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件确保构建是可重现的\")]),e._v(\" \"),t(\"p\",[e._v(\"Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。例如，如果下周 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 的 \"),t(\"code\",[e._v(\"0.5.6\")]),e._v(\" 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷，这时会发生什么呢？\")]),e._v(\" \"),t(\"p\",[e._v(\"这个问题的答案是 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件。它在第一次运行 \"),t(\"code\",[e._v(\"cargo build\")]),e._v(\" 时创建，并放在 \"),t(\"em\",[e._v(\"guessing_game\")]),e._v(\" 目录。当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件。当将来构建项目时，Cargo 会发现 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 \"),t(\"code\",[e._v(\"0.5.5\")]),e._v(\" 直到你显式升级，多亏有了 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"更新-crate-到一个新版本\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更新-crate-到一个新版本\"}},[e._v(\"#\")]),e._v(\" 更新 crate 到一个新版本\")]),e._v(\" \"),t(\"p\",[e._v(\"当你 \"),t(\"strong\",[e._v(\"确实\")]),e._v(\" 需要升级 crate 时，Cargo 提供了另一个命令，\"),t(\"code\",[e._v(\"update\")]),e._v(\"，它会忽略 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件，并计算出所有符合 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 声明的最新版本。如果成功了，Cargo 会把这些版本写入 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件。\")]),e._v(\" \"),t(\"p\",[e._v(\"不过，Cargo 默认只会寻找大于 \"),t(\"code\",[e._v(\"0.5.5\")]),e._v(\" 而小于 \"),t(\"code\",[e._v(\"0.6.0\")]),e._v(\" 的版本。如果 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 发布了两个新版本，\"),t(\"code\",[e._v(\"0.5.6\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"0.6.0\")]),e._v(\"，在运行 \"),t(\"code\",[e._v(\"cargo update\")]),e._v(\" 时会出现如下内容：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo update\\n    Updating crates.io index\\n    Updating rand v0.5.5 -> v0.5.6\\n\")])])]),t(\"p\",[e._v(\"这时，你也会注意到的 \"),t(\"em\",[e._v(\"Cargo.lock\")]),e._v(\" 文件中的变化无外乎现在使用的 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 版本是\"),t(\"code\",[e._v(\"0.5.6\")])]),e._v(\" \"),t(\"p\",[e._v(\"如果想要使用 \"),t(\"code\",[e._v(\"0.6.0\")]),e._v(\" 版本的 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" 或是任何 \"),t(\"code\",[e._v(\"0.6.x\")]),e._v(\" 系列的版本，必须像这样更新 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 文件：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-toml extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-toml\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"[\")]),t(\"span\",{pre:!0,attrs:{class:\"token table class-name\"}},[e._v(\"dependencies\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"]\")]),e._v(\"\\n\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token key property\"}},[e._v(\"rand\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"=\")]),e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v('\"0.6.0\"')]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"下一次运行 \"),t(\"code\",[e._v(\"cargo build\")]),e._v(\" 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。\")]),e._v(\" \"),t(\"p\",[e._v(\"第十四章会讲到 \"),t(\"a\",{attrs:{href:\"http://doc.crates.io\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Cargo\"),t(\"OutboundLink\")],1),e._v(\" 及其\"),t(\"a\",{attrs:{href:\"http://doc.crates.io/crates-io.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"生态系统\"),t(\"OutboundLink\")],1),e._v(\" 的更多内容，不过目前你只需要了解这么多。通过 Cargo 复用库文件非常容易，因此 Rustacean 能够编写出由很多包组装而成的更轻巧的项目。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"生成一个随机数\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#生成一个随机数\"}},[e._v(\"#\")]),e._v(\" 生成一个随机数\")]),e._v(\" \"),t(\"p\",[e._v(\"你已经把 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 添加到 \"),t(\"em\",[e._v(\"Cargo.toml\")]),e._v(\" 了，让我们开始使用 \"),t(\"code\",[e._v(\"rand\")]),e._v(\"。下一步是更新 \"),t(\"em\",[e._v(\"src/main.rs\")]),e._v(\"，如示例 2-3 所示。\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('use std::io;\\nuse rand::Rng;\\n\\nfn main() {\\n    println!(\"Guess the number!\");\\n\\n    let secret_number = rand::thread_rng().gen_range(1, 101);\\n\\n    println!(\"The secret number is: {}\", secret_number);\\n\\n    println!(\"Please input your guess.\");\\n\\n    let mut guess = String::new();\\n\\n    io::stdin().read_line(&mut guess)\\n        .expect(\"Failed to read line\");\\n\\n    println!(\"You guessed: {}\", guess);\\n}\\n')])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-3：添加生成随机数的代码\")])]),e._v(\" \"),t(\"p\",[e._v(\"首先，我们新增了一行 \"),t(\"code\",[e._v(\"use\")]),e._v(\"：\"),t(\"code\",[e._v(\"use rand::Rng\")]),e._v(\"。\"),t(\"code\",[e._v(\"Rng\")]),e._v(\" 是一个 trait，它定义了随机数生成器应实现的方法，想使用这些方法的话，此 trait 必须在作用域中。第十章会详细介绍 trait。\")]),e._v(\" \"),t(\"p\",[e._v(\"接下来，我们在中间还新增加了两行。\"),t(\"code\",[e._v(\"rand::thread_rng\")]),e._v(\" 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。接下来，调用随机数生成器的 \"),t(\"code\",[e._v(\"gen_range\")]),e._v(\" 方法。这个方法由刚才引入到作用域的 \"),t(\"code\",[e._v(\"Rng\")]),e._v(\" trait 定义。\"),t(\"code\",[e._v(\"gen_range\")]),e._v(\" 方法获取两个数字作为参数，并生成一个范围在两者之间的随机数。它包含下限但不包含上限，所以需要指定 \"),t(\"code\",[e._v(\"1\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"101\")]),e._v(\" 来请求一个 1 和 100 之间的数。\")]),e._v(\" \"),t(\"blockquote\",[t(\"p\",[e._v(\"注意：你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法。crate 的使用说明位于其文档中。Cargo 有一个很棒的功能是：运行 \"),t(\"code\",[e._v(\"cargo doc --open\")]),e._v(\" 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 \"),t(\"code\",[e._v(\"rand\")]),e._v(\" crate 中的其他功能感兴趣，你可以运行 \"),t(\"code\",[e._v(\"cargo doc --open\")]),e._v(\" 并点击左侧导航栏中的 \"),t(\"code\",[e._v(\"rand\")]),e._v(\"。\")])]),e._v(\" \"),t(\"p\",[e._v(\"新增加的第二行代码打印出了秘密数字。这在开发程序时很有用，因为可以测试它，不过在最终版本中会删掉它。如果游戏一开始就打印出结果就没什么可玩的了！\")]),e._v(\" \"),t(\"p\",[e._v(\"尝试运行程序几次：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nThe secret number is: 7\\nPlease input your guess.\\n4\\nYou guessed: 4\\n$ cargo run\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nThe secret number is: 83\\nPlease input your guess.\\n5\\nYou guessed: 5\\n\")])])]),t(\"p\",[e._v(\"你应该能得到不同的随机数，同时它们应该都是在 1 和 100 之间的。干得漂亮！\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"比较猜测的数字和秘密数字\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#比较猜测的数字和秘密数字\"}},[e._v(\"#\")]),e._v(\" 比较猜测的数字和秘密数字\")]),e._v(\" \"),t(\"p\",[e._v(\"现在有了用户输入和一个随机数，我们可以比较它们。这个步骤如示例 2-4 所示。注意这段代码还不能通过编译，我们稍后会解释。\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore,does_not_compile extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('use std::io;\\nuse std::cmp::Ordering;\\nuse rand::Rng;\\n\\nfn main() {\\n\\n    // ---snip---\\n\\n    println!(\"You guessed: {}\", guess);\\n\\n    match guess.cmp(&secret_number) {\\n        Ordering::Less => println!(\"Too small!\"),\\n        Ordering::Greater => println!(\"Too big!\"),\\n        Ordering::Equal => println!(\"You win!\"),\\n    }\\n}\\n')])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-4：处理比较两个数字可能的返回值\")])]),e._v(\" \"),t(\"p\",[e._v(\"新代码的第一行是另一个 \"),t(\"code\",[e._v(\"use\")]),e._v(\"，从标准库引入了一个叫做 \"),t(\"code\",[e._v(\"std::cmp::Ordering\")]),e._v(\" 的类型。同 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 一样， \"),t(\"code\",[e._v(\"Ordering\")]),e._v(\" 也是一个枚举，不过它的成员是 \"),t(\"code\",[e._v(\"Less\")]),e._v(\"、\"),t(\"code\",[e._v(\"Greater\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"Equal\")]),e._v(\"。这是比较两个值时可能出现的三种结果。\")]),e._v(\" \"),t(\"p\",[e._v(\"接着，底部的五行新代码使用了 \"),t(\"code\",[e._v(\"Ordering\")]),e._v(\" 类型，\"),t(\"code\",[e._v(\"cmp\")]),e._v(\" 方法用来比较两个值并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 与 \"),t(\"code\",[e._v(\"secret_number\")]),e._v(\" 做比较。 然后它会返回一个刚才通过 \"),t(\"code\",[e._v(\"use\")]),e._v(\" 引入作用域的 \"),t(\"code\",[e._v(\"Ordering\")]),e._v(\" 枚举的成员。使用一个 \"),t(\"RouterLink\",{attrs:{to:\"/ch06-02-match.html\"}},[t(\"code\",[e._v(\"match\")])]),e._v(\" 表达式，根据对 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"secret_number\")]),e._v(\" 调用 \"),t(\"code\",[e._v(\"cmp\")]),e._v(\" 返回的 \"),t(\"code\",[e._v(\"Ordering\")]),e._v(\" 成员来决定接下来做什么。\")],1),e._v(\" \"),t(\"p\",[e._v(\"一个 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 表达式由 \"),t(\"strong\",[e._v(\"分支（arms）\")]),e._v(\" 构成。一个分支包含一个 \"),t(\"strong\",[e._v(\"模式\")]),e._v(\"（\"),t(\"em\",[e._v(\"pattern\")]),e._v(\"）和表达式开头的值与分支模式相匹配时应该执行的代码。Rust 获取提供给 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 的值并挨个检查每个分支的模式。\"),t(\"code\",[e._v(\"match\")]),e._v(\" 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并帮助你确保没有遗漏处理。这些功能将分别在第六章和第十八章详细介绍。\")]),e._v(\" \"),t(\"p\",[e._v(\"让我们看看使用 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 表达式的例子。假设用户猜了 50，这时随机生成的秘密数字是 38。比较 50 与 38 时，因为 50 比 38 要大，\"),t(\"code\",[e._v(\"cmp\")]),e._v(\" 方法会返回 \"),t(\"code\",[e._v(\"Ordering::Greater\")]),e._v(\"。\"),t(\"code\",[e._v(\"Ordering::Greater\")]),e._v(\" 是 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 表达式得到的值。它检查第一个分支的模式，\"),t(\"code\",[e._v(\"Ordering::Less\")]),e._v(\" 与 \"),t(\"code\",[e._v(\"Ordering::Greater\")]),e._v(\"并不匹配，所以它忽略了这个分支的代码并来到下一个分支。下一个分支的模式是 \"),t(\"code\",[e._v(\"Ordering::Greater\")]),e._v(\"，\"),t(\"strong\",[e._v(\"正确\")]),e._v(\" 匹配！这个分支关联的代码被执行，在屏幕打印出 \"),t(\"code\",[e._v(\"Too big!\")]),e._v(\"。\"),t(\"code\",[e._v(\"match\")]),e._v(\" 表达式就此终止，因为该场景下没有检查最后一个分支的必要。\")]),e._v(\" \"),t(\"p\",[e._v(\"然而，示例 2-4 的代码并不能编译，可以尝试一下：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo build\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\nerror[E0308]: mismatched types\\n  --\\x3e src/main.rs:23:21\\n   |\\n23 |     match guess.cmp(&secret_number) {\\n   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer\\n   |\\n   = note: expected type `&std::string::String`\\n   = note:    found type `&{integer}`\\n\\nerror: aborting due to previous error\\nCould not compile `guessing_game`.\\n\")])])]),t(\"p\",[e._v(\"错误的核心表明这里有 \"),t(\"strong\",[e._v(\"不匹配的类型\")]),e._v(\"（\"),t(\"em\",[e._v(\"mismatched types\")]),e._v(\"）。Rust 有一个静态强类型系统，同时也有类型推断。当我们写出 \"),t(\"code\",[e._v(\"let guess = String::new()\")]),e._v(\" 时，Rust 推断出 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 应该是 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 类型，并不需要我们写出类型。另一方面，\"),t(\"code\",[e._v(\"secret_number\")]),e._v(\"，是数字类型。几个数字类型拥有 1 到 100 之间的值：32 位数字 \"),t(\"code\",[e._v(\"i32\")]),e._v(\"；32 位无符号数字 \"),t(\"code\",[e._v(\"u32\")]),e._v(\"；64 位数字 \"),t(\"code\",[e._v(\"i64\")]),e._v(\" 等等。Rust 默认使用 \"),t(\"code\",[e._v(\"i32\")]),e._v(\"，所以它是 \"),t(\"code\",[e._v(\"secret_number\")]),e._v(\" 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。这里错误的原因在于 Rust 不会比较字符串类型和数字类型。\")]),e._v(\" \"),t(\"p\",[e._v(\"所以我们必须把从输入中读取到的 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 转换为一个真正的数字类型，才好与秘密数字进行比较。这可以通过在 \"),t(\"code\",[e._v(\"main\")]),e._v(\" 函数体中增加如下两行代码来实现：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('// --snip--\\n\\n    let mut guess = String::new();\\n\\n    io::stdin().read_line(&mut guess)\\n        .expect(\"Failed to read line\");\\n\\n    let guess: u32 = guess.trim().parse()\\n        .expect(\"Please type a number!\");\\n\\n    println!(\"You guessed: {}\", guess);\\n\\n    match guess.cmp(&secret_number) {\\n        Ordering::Less => println!(\"Too small!\"),\\n        Ordering::Greater => println!(\"Too big!\"),\\n        Ordering::Equal => println!(\"You win!\"),\\n    }\\n}\\n')])])]),t(\"p\",[e._v(\"这两行新代码是：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('let guess: u32 = guess.trim().parse()\\n    .expect(\"Please type a number!\");\\n')])])]),t(\"p\",[e._v(\"这里创建了一个叫做 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 的变量。不过等等，不是已经有了一个叫做 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 的变量了吗？确实如此，不过 Rust 允许用一个新值来 \"),t(\"strong\",[e._v(\"隐藏\")]),e._v(\" （\"),t(\"em\",[e._v(\"shadow\")]),e._v(\"） \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 之前的值。这个功能常用在需要转换值类型之类的场景。它允许我们复用 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 变量的名字，而不是被迫创建两个不同变量，诸如 \"),t(\"code\",[e._v(\"guess_str\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 之类。（第三章会介绍 shadowing 的更多细节。）\")]),e._v(\" \"),t(\"p\",[e._v(\"我们将 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 绑定到 \"),t(\"code\",[e._v(\"guess.trim().parse()\")]),e._v(\" 表达式上。表达式中的 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 是包含输入的原始 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 类型。\"),t(\"code\",[e._v(\"String\")]),e._v(\" 实例的 \"),t(\"code\",[e._v(\"trim\")]),e._v(\" 方法会去除字符串开头和结尾的空白字符。\"),t(\"code\",[e._v(\"u32\")]),e._v(\" 只能由数字字符转换，不过用户必须输入 \"),t(\"span\",{staticClass:\"keystroke\"},[e._v(\"enter\")]),e._v(\" 键才能让 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 返回，然而用户按下 \"),t(\"span\",{staticClass:\"keystroke\"},[e._v(\"enter\")]),e._v(\" 键时，会在字符串中增加一个换行（newline）符。例如，用户输入 \"),t(\"span\",{staticClass:\"keystroke\"},[e._v(\"5\")]),e._v(\" 并按下 \"),t(\"span\",{staticClass:\"keystroke\"},[e._v(\"enter\")]),e._v(\"，\"),t(\"code\",[e._v(\"guess\")]),e._v(\" 看起来像这样：\"),t(\"code\",[e._v(\"5\\\\n\")]),e._v(\"。\"),t(\"code\",[e._v(\"\\\\n\")]),e._v(\" 代表 “换行”，回车键。\"),t(\"code\",[e._v(\"trim\")]),e._v(\" 方法消除 \"),t(\"code\",[e._v(\"\\\\n\")]),e._v(\"，只留下 \"),t(\"code\",[e._v(\"5\")]),e._v(\"。\")]),e._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://doc.rust-lang.org/std/primitive.str.html#method.parse\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"字符串的 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 方法\"),t(\"OutboundLink\")],1),e._v(\" 将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 \"),t(\"code\",[e._v(\"let guess: u32\")]),e._v(\" 指定。\"),t(\"code\",[e._v(\"guess\")]),e._v(\" 后面的冒号（\"),t(\"code\",[e._v(\":\")]),e._v(\"）告诉 Rust 我们指定了变量的类型。Rust 有一些内建的数字类型；\"),t(\"code\",[e._v(\"u32\")]),e._v(\" 是一个无符号的 32 位整型。对于不大的正整数来说，它是不错的类型，第三章还会讲到其他数字类型。另外，程序中的 \"),t(\"code\",[e._v(\"u32\")]),e._v(\" 注解以及与 \"),t(\"code\",[e._v(\"secret_number\")]),e._v(\" 的比较，意味着 Rust 会推断出 \"),t(\"code\",[e._v(\"secret_number\")]),e._v(\" 也是 \"),t(\"code\",[e._v(\"u32\")]),e._v(\" 类型。现在可以使用相同类型比较两个值了！\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"parse\")]),e._v(\" 调用很容易产生错误。例如，字符串中包含 \"),t(\"code\",[e._v(\"A👍%\")]),e._v(\"，就无法将其转换为一个数字。因此，\"),t(\"code\",[e._v(\"parse\")]),e._v(\" 方法返回一个 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型。像之前 \"),t(\"a\",{attrs:{href:\"#handling-potential-failure-with-the-result-type\"}},[e._v(\"“使用 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型来处理潜在的错误”\")]),e._v(\" 讨论的 \"),t(\"code\",[e._v(\"read_line\")]),e._v(\" 方法那样，再次按部就班的用 \"),t(\"code\",[e._v(\"expect\")]),e._v(\" 方法处理即可。如果 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 不能从字符串生成一个数字，返回一个 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 的 \"),t(\"code\",[e._v(\"Err\")]),e._v(\" 成员时，\"),t(\"code\",[e._v(\"expect\")]),e._v(\" 会使游戏崩溃并打印附带的信息。如果 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 成功地将字符串转换为一个数字，它会返回 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 的 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 成员，然后 \"),t(\"code\",[e._v(\"expect\")]),e._v(\" 会返回 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 值中的数字。\")]),e._v(\" \"),t(\"p\",[e._v(\"现在让我们运行程序！\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nThe secret number is: 58\\nPlease input your guess.\\n  76\\nYou guessed: 76\\nToo big!\\n\")])])]),t(\"p\",[e._v(\"漂亮！即便是在猜测之前添加了空格，程序依然能判断出用户猜测了 76。多运行程序几次，输入不同的数字来检验不同的行为：猜一个正确的数字，猜一个过大的数字和猜一个过小的数字。\")]),e._v(\" \"),t(\"p\",[e._v(\"现在游戏已经大体上能玩了，不过用户只能猜一次。增加一个循环来改变它吧！\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"使用循环来允许多次猜测\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用循环来允许多次猜测\"}},[e._v(\"#\")]),e._v(\" 使用循环来允许多次猜测\")]),e._v(\" \"),t(\"p\",[t(\"code\",[e._v(\"loop\")]),e._v(\" 关键字创建了一个无限循环。将其加入后，用户可以反复猜测：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('// --snip--\\n\\n    println!(\"The secret number is: {}\", secret_number);\\n\\n    loop {\\n        println!(\"Please input your guess.\");\\n\\n        // --snip--\\n\\n        match guess.cmp(&secret_number) {\\n            Ordering::Less => println!(\"Too small!\"),\\n            Ordering::Greater => println!(\"Too big!\"),\\n            Ordering::Equal => println!(\"You win!\"),\\n        }\\n    }\\n}\\n')])])]),t(\"p\",[e._v(\"如上所示，我们将提示用户猜测之后的所有内容放入了循环。确保 loop 循环中的代码多缩进四个空格，再次运行程序。注意这里有一个新问题，因为程序忠实地执行了我们的要求：永远地请求另一个猜测，用户好像无法退出啊！\")]),e._v(\" \"),t(\"p\",[e._v(\"用户总能使用 \"),t(\"span\",{staticClass:\"keystroke\"},[e._v(\"ctrl-c\")]),e._v(\" 终止程序。不过还有另一个方法跳出无限循环，就是 \"),t(\"a\",{attrs:{href:\"#comparing-the-guess-to-the-secret-number\"}},[e._v(\"“比较猜测与秘密数字”\")]),e._v(\" 部分提到的 \"),t(\"code\",[e._v(\"parse\")]),e._v(\"：如果用户输入的答案不是一个数字，程序会崩溃。用户可以利用这一点来退出，如下所示：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nThe secret number is: 59\\nPlease input your guess.\\n45\\nYou guessed: 45\\nToo small!\\nPlease input your guess.\\n60\\nYou guessed: 60\\nToo big!\\nPlease input your guess.\\n59\\nYou guessed: 59\\nYou win!\\nPlease input your guess.\\nquit\\nthread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\nerror: Process didn't exit successfully: `target/debug/guess` (exit code: 101)\\n\")])])]),t(\"p\",[e._v(\"输入 \"),t(\"code\",[e._v(\"quit\")]),e._v(\" 确实退出了程序，同时其他任何非数字输入也一样。然而，这并不理想，我们想要当猜测正确的数字时游戏能自动退出。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"猜测正确后退出\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#猜测正确后退出\"}},[e._v(\"#\")]),e._v(\" 猜测正确后退出\")]),e._v(\" \"),t(\"p\",[e._v(\"让我们增加一个 \"),t(\"code\",[e._v(\"break\")]),e._v(\" 语句，在用户猜对时退出游戏：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('// --snip--\\n\\n        match guess.cmp(&secret_number) {\\n            Ordering::Less => println!(\"Too small!\"),\\n            Ordering::Greater => println!(\"Too big!\"),\\n            Ordering::Equal => {\\n                println!(\"You win!\");\\n                break;\\n            }\\n        }\\n    }\\n}\\n')])])]),t(\"p\",[e._v(\"通过在 \"),t(\"code\",[e._v(\"You win!\")]),e._v(\" 之后增加一行 \"),t(\"code\",[e._v(\"break\")]),e._v(\"，用户猜对了神秘数字后会退出循环。退出循环也意味着退出程序，因为循环是 \"),t(\"code\",[e._v(\"main\")]),e._v(\" 的最后一部分。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"处理无效输入\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#处理无效输入\"}},[e._v(\"#\")]),e._v(\" 处理无效输入\")]),e._v(\" \"),t(\"p\",[e._v(\"为了进一步改善游戏性，不要在用户输入非数字时崩溃，需要忽略非数字，让用户可以继续猜测。可以通过修改 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 将 \"),t(\"code\",[e._v(\"String\")]),e._v(\" 转化为 \"),t(\"code\",[e._v(\"u32\")]),e._v(\" 那部分代码来实现，如示例 2-5 所示：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('// --snip--\\n\\nio::stdin().read_line(&mut guess)\\n    .expect(\"Failed to read line\");\\n\\nlet guess: u32 = match guess.trim().parse() {\\n    Ok(num) => num,\\n    Err(_) => continue,\\n};\\n\\nprintln!(\"You guessed: {}\", guess);\\n\\n// --snip--\\n')])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-5: 忽略非数字的猜测并重新请求数字而不是让程序崩溃\")])]),e._v(\" \"),t(\"p\",[e._v(\"将 \"),t(\"code\",[e._v(\"expect\")]),e._v(\" 调用换成 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 语句，是从遇到错误就崩溃转换到真正处理错误的惯用方法。须知 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 返回一个 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 类型，而 \"),t(\"code\",[e._v(\"Result\")]),e._v(\" 是一个拥有 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 或 \"),t(\"code\",[e._v(\"Err\")]),e._v(\" 成员的枚举。这里使用的 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 表达式，和之前处理 \"),t(\"code\",[e._v(\"cmp\")]),e._v(\" 方法返回 \"),t(\"code\",[e._v(\"Ordering\")]),e._v(\" 时用的一样。\")]),e._v(\" \"),t(\"p\",[e._v(\"如果 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 能够成功的将字符串转换为一个数字，它会返回一个包含结果数字的 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\"。这个 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 值与 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 第一个分支的模式相匹配，该分支对应的动作返回 \"),t(\"code\",[e._v(\"Ok\")]),e._v(\" 值中的数字 \"),t(\"code\",[e._v(\"num\")]),e._v(\"，最后如愿变成新创建的 \"),t(\"code\",[e._v(\"guess\")]),e._v(\" 变量。\")]),e._v(\" \"),t(\"p\",[e._v(\"如果 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" \"),t(\"em\",[e._v(\"不\")]),e._v(\" 能将字符串转换为一个数字，它会返回一个包含更多错误信息的 \"),t(\"code\",[e._v(\"Err\")]),e._v(\"。\"),t(\"code\",[e._v(\"Err\")]),e._v(\" 值不能匹配第一个 \"),t(\"code\",[e._v(\"match\")]),e._v(\" 分支的 \"),t(\"code\",[e._v(\"Ok(num)\")]),e._v(\" 模式，但是会匹配第二个分支的 \"),t(\"code\",[e._v(\"Err(_)\")]),e._v(\" 模式：\"),t(\"code\",[e._v(\"_\")]),e._v(\" 是一个通配符值，本例中用来匹配所有 \"),t(\"code\",[e._v(\"Err\")]),e._v(\" 值，不管其中有何种信息。所以程序会执行第二个分支的动作，\"),t(\"code\",[e._v(\"continue\")]),e._v(\" 意味着进入 \"),t(\"code\",[e._v(\"loop\")]),e._v(\" 的下一次循环，请求另一个猜测。这样程序就有效的忽略了 \"),t(\"code\",[e._v(\"parse\")]),e._v(\" 可能遇到的所有错误！\")]),e._v(\" \"),t(\"p\",[e._v(\"现在万事俱备，只需运行 \"),t(\"code\",[e._v(\"cargo run\")]),e._v(\"：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"$ cargo run\\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\\n     Running `target/debug/guessing_game`\\nGuess the number!\\nThe secret number is: 61\\nPlease input your guess.\\n10\\nYou guessed: 10\\nToo small!\\nPlease input your guess.\\n99\\nYou guessed: 99\\nToo big!\\nPlease input your guess.\\nfoo\\nPlease input your guess.\\n61\\nYou guessed: 61\\nYou win!\\n\")])])]),t(\"p\",[e._v(\"太棒了！再有最后一个小的修改，就能完成猜猜看游戏了：还记得程序依然会打印出秘密数字。在测试时还好，但正式发布时会毁了游戏。删掉打印秘密数字的 \"),t(\"code\",[e._v(\"println!\")]),e._v(\"。示例 2-6 为最终代码：\")]),e._v(\" \"),t(\"p\",[t(\"span\",{staticClass:\"filename\"},[e._v(\"文件名: src/main.rs\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-rust,ignore extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('use std::io;\\nuse std::cmp::Ordering;\\nuse rand::Rng;\\n\\nfn main() {\\n    println!(\"Guess the number!\");\\n\\n    let secret_number = rand::thread_rng().gen_range(1, 101);\\n\\n    loop {\\n        println!(\"Please input your guess.\");\\n\\n        let mut guess = String::new();\\n\\n        io::stdin().read_line(&mut guess)\\n            .expect(\"Failed to read line\");\\n\\n        let guess: u32 = match guess.trim().parse() {\\n            Ok(num) => num,\\n            Err(_) => continue,\\n        };\\n\\n        println!(\"You guessed: {}\", guess);\\n\\n        match guess.cmp(&secret_number) {\\n            Ordering::Less => println!(\"Too small!\"),\\n            Ordering::Greater => println!(\"Too big!\"),\\n            Ordering::Equal => {\\n                println!(\"You win!\");\\n                break;\\n            }\\n        }\\n    }\\n}\\n')])])]),t(\"p\",[t(\"span\",{staticClass:\"caption\"},[e._v(\"示例 2-6：猜猜看游戏的完整代码\")])]),e._v(\" \"),t(\"h2\",{attrs:{id:\"总结\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[e._v(\"#\")]),e._v(\" 总结\")]),e._v(\" \"),t(\"p\",[e._v(\"此时此刻，你顺利完成了猜猜看游戏。恭喜！\")]),e._v(\" \"),t(\"p\",[e._v(\"本项目通过动手实践，向你介绍了 Rust 新概念：\"),t(\"code\",[e._v(\"let\")]),e._v(\"、\"),t(\"code\",[e._v(\"match\")]),e._v(\"、方法、关联函数、使用外部 crate 等等，接下来的几章，你会继续深入学习这些概念。第三章介绍大部分编程语言都有的概念，比如变量、数据类型和函数，以及如何在 Rust 中使用它们。第四章探索所有权（ownership），这是一个 Rust 同其他语言大不相同的功能。第五章讨论结构体和方法的语法，而第六章侧重解释枚举。\")])])}),[],!1,null,null,null);s.default=a.exports}}]);","extractedComments":[]}